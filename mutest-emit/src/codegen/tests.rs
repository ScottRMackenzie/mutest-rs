use std::iter;

use itertools::Itertools;
use rustc_expand::base::ResolverExpand;
use rustc_resolve::Resolver;
use smallvec::{SmallVec, smallvec};

use crate::analysis::tests::Test;
use crate::codegen::ast;
use crate::codegen::ast::P;
use crate::codegen::ast::entry::EntryPointType;
use crate::codegen::ast::mut_visit::{ExpectOne, MutVisitor};
use crate::codegen::symbols::{DUMMY_SP, Ident, Symbol, path, sym};
use crate::codegen::symbols::hygiene::AstPass;

fn is_cfg_test_attr(attr: &ast::Attribute) -> bool {
    // `#[cfg(test)]`
    attr.has_name(sym::cfg) && attr.meta_item_list().is_some_and(|list| list.iter().any(|item| item.has_name(sym::test)))
}

fn unambiguous_test_item_ident(ident: &Ident) -> Ident {
    let symbol = Symbol::intern(&format!("{}_impl", ident));
    Ident::new(symbol, ident.span)
}

fn is_extern_crate_decl(item: &ast::Item, sym: Symbol) -> bool {
    if let ast::ItemKind::ExternCrate(..) = item.kind {
        if item.ident.name == sym {
            return true;
        }
    }

    false
}

fn dedupe_extern_crate_decls(items: &mut Vec<P<ast::Item>>, sym: Symbol) -> Option<P<ast::Item>> {
    let Some((first_extern_crate_index, _)) = items.iter().find_position(|&item| is_extern_crate_decl(item, sym)) else { return None; };

    let mut i = first_extern_crate_index + 1;
    while let Some(item) = items.get(i) {
        if !is_extern_crate_decl(item, sym) {
            i += 1;
            continue;
        }

        items.remove(i);
    }

    Some(items[first_extern_crate_index].clone())
}

fn ensure_test_scope(items: &mut Vec<P<ast::Item>>) {
    let Some(first_test_extern_crate) = dedupe_extern_crate_decls(items, sym::test) else { return; };
    let None = dedupe_extern_crate_decls(items, *sym::mutest_runtime) else { return; };
    items.push(ast::mk::item_extern_crate(first_test_extern_crate.span, *sym::mutest_runtime, None));
}

struct TestCaseCleaner<'tst> {
    tests: &'tst Vec<Test>,
}

impl<'tst> ast::mut_visit::MutVisitor for TestCaseCleaner<'tst> {
    fn visit_crate(&mut self, c: &mut ast::Crate) {
        ast::mut_visit::noop_visit_crate(c, self);

        ensure_test_scope(&mut c.items);
    }

    fn flat_map_item(&mut self, i: P<ast::Item>) -> SmallVec<[P<ast::Item>; 1]> {
        let mut item = i.into_inner();

        if let ast::ItemKind::Mod(..) = item.kind {
            ast::mut_visit::noop_visit_item_kind(&mut item.kind, self);

            if let ast::ItemKind::Mod(_, ast::ModKind::Loaded(ref mut items, _, _)) = item.kind {
                ensure_test_scope(items);
            }
        }

        if let Some(test) = self.tests.iter().find(|&test| test.descriptor.id == item.id) {
            // #[allow(non_upper_case_globals)]
            let allow_non_upper_case_globals_attr = ast::attr::mk_attr_outer(ast::attr::mk_list_item(
                Ident::new(sym::allow, item.span),
                vec![ast::attr::mk_nested_word_item(Ident::new(*sym::non_upper_case_globals, item.span))],
            ));

            item.attrs = item.attrs.into_iter()
                // Remove the `#[cfg(test)]` attribute generated by the rustc test harness.
                .filter(|attr| !is_cfg_test_attr(attr))
                .chain(iter::once(allow_non_upper_case_globals_attr))
                .collect();

            if let ast::ItemKind::Const(_, _, Some(ref mut test_const_expr)) = item.kind
                && let ast::ExprKind::Struct(ref mut test_const_struct_expr) = test_const_expr.kind
                && let Some(test_fn_field) = test_const_struct_expr.fields.iter_mut().find(|field| field.ident.name == Symbol::intern("testfn"))
                && let ast::ExprKind::Call(_, ref mut test_lib_call_args) = test_fn_field.expr.kind
                && let Some(test_lib_call_lambda) = test_lib_call_args.first_mut()
                && let ast::ExprKind::Closure(_, _, _, _, ref mut test_lib_call_body, _) = test_lib_call_lambda.kind
                && let ast::ExprKind::Call(_, ref mut test_assert_call_args) = test_lib_call_body.kind
                && let Some(test_assert_call_arg) = test_assert_call_args.first_mut()
                && let ast::ExprKind::Call(ref test_fn_path, _) = test_assert_call_arg.kind
                && let ast::ExprKind::Path(_, ref test_fn_path) = test_fn_path.kind
            {
                *test_assert_call_arg = ast::mk::expr_call_path(test_assert_call_arg.span,
                    ast::mk::path_local(path::wrap(test_assert_call_arg.span)),
                    vec![ast::mk::expr_ref(test_fn_path.span, ast::mk::expr_ident(test_fn_path.span, unambiguous_test_item_ident(&test.descriptor.ident)))],
                );
            }
        }

        if let Some(test) = self.tests.iter().find(|&test| test.item.id == item.id) {
            item.ident = unambiguous_test_item_ident(&test.descriptor.ident);
        }

        smallvec![P(item)]
    }
}

pub fn clean_up_test_cases(tests: &Vec<Test>, krate: &mut ast::Crate) {
    let mut cleaner = TestCaseCleaner { tests };
    cleaner.visit_crate(krate);
}

fn entry_point_type(item: &ast::Item, depth: usize) -> EntryPointType {
    match item.kind {
        ast::ItemKind::Fn(..) => {
            if item.attrs.iter().any(|attr| attr.has_name(sym::start)) {
                EntryPointType::Start
            } else if item.attrs.iter().any(|attr| attr.has_name(sym::rustc_main)) {
                EntryPointType::MainAttr
            } else if item.ident.name == sym::main {
                if depth == 0 {
                    EntryPointType::MainNamed
                } else {
                    EntryPointType::OtherMain
                }
            } else {
                EntryPointType::None
            }
        }
        _ => EntryPointType::None,
    }
}

fn is_allow_dead_code_attr(attr: &ast::Attribute) -> bool {
    // `#[allow(dead_code)]`
    attr.has_name(sym::allow) && attr.meta_item_list().is_some_and(|list| list.iter().any(|item| item.has_name(sym::dead_code)))
}

struct EntryPointCleaner {
    depth: usize,
}

impl ast::mut_visit::MutVisitor for EntryPointCleaner {
    fn flat_map_item(&mut self, i: P<ast::Item>) -> SmallVec<[P<ast::Item>; 1]> {
        self.depth += 1;
        let item = ast::mut_visit::noop_flat_map_item(i, self).expect_one("noop did something");
        self.depth -= 1;

        let mut item = item.into_inner();

        match entry_point_type(&item, self.depth) {
            // Retain items that are user-defined entry points as dead-code.
            EntryPointType::MainNamed | EntryPointType::Start => {
                if item.ident.name == sym::main {
                    item.ident = Ident::new(Symbol::intern("unused_main"), item.ident.span);
                }

                let allow_dead_code_attr = ast::attr::mk_attr_outer(ast::attr::mk_list_item(
                    Ident::new(sym::allow, item.span),
                    vec![ast::attr::mk_nested_word_item(Ident::new(sym::dead_code, item.span))],
                ));

                item.attrs = item.attrs.into_iter()
                    .filter(|attr| !attr.has_name(sym::start))
                    // Remove any existing `#[allow(dead_code)]` attributes (e.g. those generated by the rustc test harness).
                    .filter(|attr| !is_allow_dead_code_attr(attr))
                    .chain(iter::once(allow_dead_code_attr))
                    .collect();
            }
            // Drop the entry point generated by the rustc test harness, which is marked with `#[rustc_main]`.
            EntryPointType::MainAttr => return smallvec![],
            // Ignore items that are not entry points.
            EntryPointType::None | EntryPointType::OtherMain => {}
        };

        smallvec![P(item)]
    }
}

pub fn clean_entry_points(krate: &mut ast::Crate) {
    let mut cleaner = EntryPointCleaner { depth: 0 };
    cleaner.visit_crate(krate);
}

pub fn generate_dummy_main(resolver: &mut Resolver, krate: &mut ast::Crate) {
    let expn_id = resolver.expansion_for_ast_pass(
        DUMMY_SP,
        AstPass::TestHarness,
        &[sym::test, sym::rustc_attrs],
        None,
    );
    let def_site = DUMMY_SP.with_def_site_ctxt(expn_id.to_expn_id());

    let def = def_site;

    // pub fn main {}
    let vis = ast::mk::vis_pub(def);
    let ident = Ident::new(sym::main, def);
    let body = ast::mk::block(def, vec![]);
    let main = ast::mk::item_fn(def, vis, ident, None, None, vec![], None, Some(body));

    krate.items.push(main);
}

pub fn remove_dummy_main(krate: &mut ast::Crate) {
    krate.items.retain(|item| item.ident.name != sym::main);
}
