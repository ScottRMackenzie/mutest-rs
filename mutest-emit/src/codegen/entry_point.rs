use std::iter;

use rustc_expand::base::ResolverExpand;
use rustc_resolve::Resolver;
use smallvec::{SmallVec, smallvec};

use crate::codegen::ast;
use crate::codegen::ast::P;
use crate::codegen::ast::entry::EntryPointType;
use crate::codegen::ast::mut_visit::{ExpectOne, MutVisitor};
use crate::codegen::symbols::{DUMMY_SP, Ident, Symbol, sym};
use crate::codegen::symbols::hygiene::AstPass;

fn entry_point_type(item: &ast::Item, depth: usize) -> EntryPointType {
    match item.kind {
        ast::ItemKind::Fn(..) => {
            if item.attrs.iter().any(|attr| attr.has_name(sym::start)) {
                EntryPointType::Start
            } else if item.attrs.iter().any(|attr| attr.has_name(sym::rustc_main)) {
                EntryPointType::MainAttr
            } else if item.ident.name == sym::main {
                if depth == 0 {
                    EntryPointType::MainNamed
                } else {
                    EntryPointType::OtherMain
                }
            } else {
                EntryPointType::None
            }
        }
        _ => EntryPointType::None,
    }
}

fn is_allow_dead_code_attr(attr: &ast::Attribute) -> bool {
    // `#[allow(dead_code)]`
    attr.has_name(sym::allow) && attr.meta_item_list().is_some_and(|list| list.iter().any(|item| item.has_name(sym::dead_code)))
}

struct EntryPointCleaner {
    depth: usize,
}

impl ast::mut_visit::MutVisitor for EntryPointCleaner {
    fn flat_map_item(&mut self, i: P<ast::Item>) -> SmallVec<[P<ast::Item>; 1]> {
        self.depth += 1;
        let item = ast::mut_visit::noop_flat_map_item(i, self).expect_one("noop did something");
        self.depth -= 1;

        let mut item = item.into_inner();

        match entry_point_type(&item, self.depth) {
            // Retain items that are user-defined entry points as dead-code.
            EntryPointType::MainNamed | EntryPointType::Start => {
                if item.ident.name == sym::main {
                    item.ident = Ident::new(Symbol::intern("unused_main"), item.ident.span);
                }

                let allow_dead_code_attr = ast::attr::mk_attr_outer(ast::attr::mk_list_item(
                    Ident::new(sym::allow, item.span),
                    vec![ast::attr::mk_nested_word_item(Ident::new(sym::dead_code, item.span))],
                ));

                item.attrs = item.attrs.into_iter()
                    .filter(|attr| !attr.has_name(sym::start))
                    // Remove any existing `#[allow(dead_code)]` attributes (e.g. those generated by the rustc test harness).
                    .filter(|attr| !is_allow_dead_code_attr(attr))
                    .chain(iter::once(allow_dead_code_attr))
                    .collect();
            }
            // Drop the entry point generated by the rustc test harness, which is marked with `#[rustc_main]`.
            EntryPointType::MainAttr => return smallvec![],
            // Ignore items that are not entry points.
            EntryPointType::None | EntryPointType::OtherMain => {}
        };

        smallvec![P(item)]
    }
}

pub fn clean_entry_points(krate: &mut ast::Crate) {
    let mut cleaner = EntryPointCleaner { depth: 0 };
    cleaner.visit_crate(krate);
}

pub fn generate_dummy_main(resolver: &mut Resolver, krate: &mut ast::Crate) {
    let expn_id = resolver.expansion_for_ast_pass(
        DUMMY_SP,
        AstPass::TestHarness,
        &[sym::test, sym::rustc_attrs],
        None,
    );
    let def_site = DUMMY_SP.with_def_site_ctxt(expn_id.to_expn_id());

    let def = def_site;

    // pub fn main {}
    let vis = ast::mk::vis_pub(def);
    let ident = Ident::new(sym::main, def);
    let body = ast::mk::block(def, vec![]);
    let main = ast::mk::item_fn(def, vis, ident, None, None, vec![], None, Some(body));

    krate.items.push(main);
}

pub fn remove_dummy_main(krate: &mut ast::Crate) {
    krate.items.retain(|item| item.ident.name != sym::main);
}
